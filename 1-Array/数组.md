# 数组

## 基本概念

数组：**数组是存放在连续内存空间上的相同类型数据的集合。**

- **数组下标都是从0开始的。**
- **数组内存空间的地址是连续的**

**数组的元素是不能删的，只能覆盖。**

C++中二维数组的地址是连续的

```c++
#include <iostream>

int main()
{
    //1.二维数组的地址,C++中是连续分布的
    int array[2][3]= {
        {1,2,3},
        {4,5,6}
    };
    std::cout << "Array address:\n";
    std::cout << "array[0][0] = " << &array[0][0] << std::endl;
    std::cout << "array[0][1] = " << &array[0][1] << std::endl; 
    std::cout << "array[0][2] = " << &array[0][2] << std::endl;
    std::cout << "array[1][0] = " << &array[1][0] << std::endl;
    std::cout << "array[1][1] = " << &array[1][1] << std::endl;
    std::cout << "array[1][2] = " << &array[1][2] << std::endl;

    return 0;
}
```

结果：

```
Array address:
array[0][0] = 0x5ffe80
array[0][1] = 0x5ffe84
array[0][2] = 0x5ffe88
array[1][0] = 0x5ffe8c
array[1][1] = 0x5ffe90
array[1][2] = 0x5ffe94
```

## 相关算法

- 二分查找
- 移除元素
- 有序数组的平方
- 长度最小的子数组
- 螺旋矩阵2
- 区间和
- 开发商购买土地

### 1.二分查找

二分查找又称折半查找，通过判断中间值修改查找区间，定位查询元素的位置。

- 边界处理最为关键：默认使用左闭右闭的方法
- 区分最终的left和right节点的意义
- 为了避免越界问题，循环中要判断边界

```c++
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) 
    {
        int left = 0;
        int right = nums.size() -1 ;

        if(right == -1)
        {
            return { -1, -1};
        }

        int mid = searchmid(nums, target, left, right);
        if(mid == -1)
        {
            return { -1, -1};
        }
        
        if(nums.size() == 1)
        {
            return { mid, mid};
        }

        //扩大找左分界
        while(mid > 0 && nums[mid - 1] == target)
        {
            mid = searchmid(nums, target, 0, mid - 1);
        }

        left = mid;

        while(mid < right && nums[mid + 1] == target)
        {
            mid = searchmid(nums, target, mid + 1, right);
        }

        right = mid;

        return { left, right};
    }

    int searchmid(vector<int>& nums, int target, int left, int right) 
    {
        while(left <= right)
        {
            int mid = (left + right) / 2;

            if(nums[mid] > target)
            {
                right = mid - 1;
            }
            else if(nums[mid] < target)
            {
                left = mid + 1;
            }
            else return mid;
        }

        return -1;
    }
};

int main(int argc, char **argv)
{
    int ret = -1;
    Solution *so = new Solution();
    vector<int> vec = {2, 2, 2};
    vector<int> ret2 = so->searchRange(vec, 2);
    cout << "[" << ret2[0] << "," << ret2[1] << "]" << endl;
    return 0;
}
```



### 2.移除元素(快慢指针)

双指针法（快慢指针法）：**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;


//本题的重点是元素排列是有序的，取绝对值是两边往中间排序
//排序从大往小排序，比较左右节点的"绝对值"可以获取最大值。
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans = nums;
        int left = 0;
        int lenth = nums.size();
        int right = lenth - 1;
        for(int i = lenth - 1; i >= 0; i--)
        {
            int x = nums[left] * nums[left];
            int y = nums[right] * nums[right];

            if(x > y)
            {
                ans[i] = x;
                left++; //更新节点找下一个最大值
            }
            else
            {
                ans[i] = y;
                right--;
            }
        }
        return ans;
    }
};

int main(int argc, char **argv)
{
    bool ret;
    Solution *so = new Solution();
    vector<int> vec = {-4,-1,0,3,10};
    vec = so->sortedSquares(vec);
    for(auto i : vec)
    {
        cout << i << " ";
    }
    return 0;
}

```

### 3.有序数组的平方

**使用双指针实现**：典型的双指针用法。

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;


//本题的重点是元素排列是有序的，取绝对值是两边往中间排序
//排序从大往小排序，比较左右节点的"绝对值"可以获取最大值。
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        vector<int> ans = nums;
        int left = 0;
        int lenth = nums.size();
        int right = lenth - 1;
        for(int i = lenth - 1; i >= 0; i--)
        {
            int x = nums[left] * nums[left];
            int y = nums[right] * nums[right];

            if(x > y)
            {
                ans[i] = x;
                left++; //更新节点找下一个最大值
            }
            else
            {
                ans[i] = y;
                right--;
            }
        }
        return ans;
    }
};

int main(int argc, char **argv)
{
    bool ret;
    Solution *so = new Solution();
    vector<int> vec = {-4,-1,0,3,10};
    vec = so->sortedSquares(vec);
    for(auto i : vec)
    {
        cout << i << " ";
    }
    return 0;
}
```

### 4.长度最小的子数组(滑动窗口)

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。滑动窗口也可以理解为双指针法的一种。

```c++
#include <iostream>
#include <vector>
#include <string>
#include <stdint.h>

using namespace std;

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0;
        int lenth = 0;
        int sum = 0;
        int ret = INT32_MAX;
        for(int i = 0; i < nums.size(); i++)
        {
            sum += nums[i];
            while(sum >= target)
            {
                lenth = (i - left + 1); 
                ret = ret > lenth ? lenth : ret;
                sum -= nums[left++];    //先sum -= nums[left]再进行left++,变更滑动窗口起始位置
            }
        }
        return  ret == INT32_MAX ? 0 : ret;   
    }
};

int main(int argc, char **argv)
{
    int ret;
    Solution *so = new Solution();
    vector<int> vec = {2,3,1,2,4,3};
    ret = so->minSubArrayLen(7, vec);
    cout << ret << endl;
    return 0;
}
```

![209.长度最小的子数组](./assets/209.长度最小的子数组.gif)

借鉴《代码随想录》的动画图。十分生动形象。

### 总结



