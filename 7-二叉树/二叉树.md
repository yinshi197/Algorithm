# 二叉树

### 基本概念

二叉树有两种主要的形式：**满二叉树**和**完全二叉树**。

#### 二叉树分类

##### 满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树

<img src="./assets/满二叉树.png" alt="满二叉树" style="zoom: 50%;" />

##### 完全二叉树

完全二叉树的定义如下：在完全二叉树中，**除了最底层节点可能没填满外**，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。

![完全二叉树](./assets/完全二叉树.png)

##### 二叉搜索树(有数值的二叉树)

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

![二叉搜索树](./assets/二叉搜索树.png)

##### 平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1**，并且左右两个子树都是一棵平衡二叉树。

![平衡二叉搜索树](./assets/平衡二叉搜索树.png)

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn

#### 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

##### 链式存储

<img src="./assets/链式存储.png" alt="链式存储" style="zoom:50%;" />

##### 顺序存储

<img src="./assets/顺序存储.png" alt="顺序存储" style="zoom:50%;" />

**如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2。**

#### 二叉树的遍历方式

二叉树主要有两种遍历方式：

1. 深度优先遍历(DFS)：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历(BFS)：一层一层的去遍历。

- 深度优先遍历：**这里前中后，其实指的就是中间节点的遍历顺序**
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

<img src="./assets/深度优先遍历.png" alt="深度优先遍历" style="zoom:67%;" />

#### 定义二叉树

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

#### 创建二叉树

```C++
#include <iostream>
#include <bits/stdc++.h>    //包含很多其他库，写算法题可以用。
using namespace std;

struct TreeNode
{
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Soilution
{
public:
    void traversal(TreeNode *cur, vector<int> &vec)
    {
        if(cur == nullptr) return;  
        vec.push_back(cur->val);    // 中
        traversal(cur->left, vec);  // 左
        traversal(cur->right, vec); // 右
    }

    //前序遍历
    vector<int> preorderTraversal(TreeNode *root)
    {
        vector<int> ret;
        traversal(root, ret);

        return ret;
    }
};

//迭代法前序创建二叉树
TreeNode* createTree(vector<char>& nodes)
{
    if(nodes.empty() || nodes[0] == '#') return nullptr;

    TreeNode* root = new TreeNode(nodes[0] - '0');
    queue<TreeNode*> que;
    que.push(root);

    int i = 1;
    while(!que.empty() && i < nodes.size())
    {
        TreeNode* cur = que.front();
        que.pop();

        if(nodes[i] != '#')
        {
            cur->left = new TreeNode(nodes[i] - '0');
            que.push(cur->left);
        }
        i++;

        if(i < nodes.size() && nodes[i] != '#')
        {
            cur->right = new TreeNode(nodes[i] - '0');
            que.push(cur->right);
        }
        i++;
    }

    return root;
}

int main(int argc, char **argv)
{
    vector<char> test;
    char ch;
    while(cin >> ch)
    {
        if(ch == 'q') break;;
        test.push_back(ch);
    }
    TreeNode *root = createTree(test);
    Soilution *so = new Soilution();
    vector<int> ret = so->preorderTraversal(root);
    for(auto i : ret)
    {
        cout << i << " ";
    }

    return 0;
}
```

### 相关算法

- 二叉树递归遍历
- 二叉树的迭代遍历
- 二叉树的统一迭代法
- 二叉树的层序遍历
- 翻转二叉树
- 对称二叉树
- 二叉树的最大深度
- 二叉树的最小深度
- 完全二叉树的节点个数

#### 二叉树递归遍历

- 深度优先遍历(DFS):前、中、后序遍历都是相对于中间节点而言。
- 递归结束条件：cur == nullptr
- 递归函数参数和返回值

```c++
//前序遍历
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == nullptr)
            return;
        vec.push_back(cur->val);
        traversal(cur->left, vec);
        traversal(cur->right, vec);
    }

    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> ret;
        traversal(root, ret);

        return ret;
    }
};
```

```c++
//中序遍历
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == nullptr)
            return;
        traversal(cur->left, vec);
        vec.push_back(cur->val);
        traversal(cur->right, vec);
    }

    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ret;
        traversal(root, ret);

        return ret;
    }
};
```

```c++
//后序遍历
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& vec) {
        if (cur == nullptr)
            return;

        traversal(cur->left, vec);
        traversal(cur->right, vec);
        vec.push_back(cur->val);
    }

    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ret;
        traversal(root, ret);

        return ret;
    }
};
```

#### 二叉树的迭代法遍历

- 前序遍历的迭代法比较简单
- 因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。

```c++
//前序遍历
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> ret;
        if(root == nullptr) return ret;	//空节点不入栈
        st.push(root);

        while(!st.empty())
        {
          TreeNode* cur = st.top();
          st.pop();
          ret.push_back(cur->val);

          if(cur->right) st.push(cur->right);	//右节点先进栈，这样出栈顺序才是正确的。
          if(cur->left) st.push(cur->left);
        }

        return ret;
    }
};
```

- 中序遍历：先找到左下角节点，再从后往前遍历。
- 使用栈存储节点

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> ret;
        TreeNode* cur = root;
        while(cur != nullptr || !st.empty())	//使用或判断，因为cur可能为nullptr但是st里面还有节点(往回走)
        {
            if(cur != nullptr)
            {
                st.push(cur);
                cur = cur->left;    //左
            }
            else
            {
                cur = st.top();
                st.pop();
                ret.push_back(cur->val); //中
                cur = cur->right;   //右
            }
        }

        return ret;
    }
};
```

- 后序遍历：**中左右**是前序遍历(最简单),后序遍历是**左右中**。
- 前序遍历修改遍历左右节点的顺序(很容易实现)-->中右左
- 翻转中右左遍历的结果就是后序遍历的结果

```c++
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> st;
        if(root == nullptr) return ret;
        st.push(root);
        
        while(!st.empty())
        {
            TreeNode *cur = st.top();
            ret.push_back(cur->val);
            st.pop();
            
            if(cur->left) st.push(cur->left);	//修改左右节点遍历顺序
            if(cur->right) st.push(cur->right);
        }

        reverse(ret.begin(), ret.end());	//翻转结果

        return ret;
    }
};
```

#### 二叉树的统一迭代法

- 标记未处理的中间节点：在压入中间节点后再压入nullptr，表示该节点已经访问过了但是没有处理

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> ret;
        stack<TreeNode*> st;
        if(root != nullptr) st.push(root);

        while(!st.empty())
        {
            TreeNode *node = st.top();  //每次都是从左节点进入下一层
            if(node)
            {
                st.pop();
                if(node->right) st.push(node->right);   //加入右节点

                st.push(node);  //加入中间节点
                st.push(nullptr);   //标记中间节点访问过，但是没有处理

                if(node->left) st.push(node->left); //最后加入左节点
            }
            else
            {
                st.pop();   //弹出空节点
                node = st.top();
                st.pop();

                ret.push_back(node->val);
            }
        }

        return ret;
    }
};
```

#### 二叉树层序遍历

- 使用队列存储节点的访问顺序
- 每次循环后queue的size就是下一层元素的数量，并且顺序都是正确的。
- 每次for循环都是遍历当前层的元素，基于这个特点有很多变形的题目。

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ret;
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        while(!que.empty())
        {
            int size = que.size();
            vector<int> vec;
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                vec.push_back(node->val);
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }

            ret.push_back(vec);
        }

        return ret;
    }
};
```

#### 翻转二叉树

##### 递归法

- 实现过程简单：前序遍历的过程中交换左右节点
- 递归法的中序遍历可能会翻转两次左右节点，所以需要按照左中左的方式遍历

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;

        swap(root->left, root->right);
        invertTree(root->left);
        invertTree(root->right);

        return root;
    }
};
```

##### 迭代法

- 实现过程：在前序遍历的过程中交换左右节点

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root == nullptr) return root;

        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty())
        {
            TreeNode *node = st.top();
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }

        return root;
    }
};
```

##### 统一的迭代法

- 对中间节点进行交换左右孩子节点

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if(root == nullptr) return root;
        st.push(root);

        while(!st.empty())
        {
            TreeNode *node = st.top();
            st.pop();
            if(node != nullptr)
            {
                if(node->right) st.push(node->right);
                if(node->left) st.push(node->left);
                st.push(node);
                st.push(nullptr);
            }
            else
            {
                node = st.top();
                swap(node->left, node->right);
                st.pop();
            }
        }

        return root;
    }
};
```

#### 对称二叉树

##### 递归法

- 递归比较左右子树的内外两侧节点是否相等

```c++
class Solution {
public:
    bool compare(TreeNode *left, TreeNode *right)
    {
        if(left == NULL && right != NULL) return false;
        else if(left != NULL && right == NULL) return false;
        else if(left == NULL && right == NULL) return true;
        else if(left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 开始递归，做下一层的判断
        bool outside = compare(left->left, right->right);
        bool inside = compare(left->right, right->left);
        return outside && inside;
    }

    bool isSymmetric(TreeNode* root) 
    {
        if(root == NULL) return true;
        
        return compare(root->left, root->right);
    }
};
```

##### 迭代法队列实现

- 使用队列成对加入元素，成对取出元素进行比较
- 从外向内进行比较
- 队列换成栈也是没问题的

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != nullptr)
        {
            que.push(root->left);
            que.push(root->right);
        }

        while(!que.empty() && !que.empty())
        {
            TreeNode *left = que.front();
            que.pop();
            TreeNode *right = que.front();
            que.pop();

            if(!left && !right) continue;

            if((!left || !right || (left->val != right->val))) return false;

            //外侧
            que.push(left->left);
            que.push(right->right);

            //内侧
            que.push(left->right);
            que.push(right->left);
        }

        return true;
    }
};
```

#### 二叉树的最大深度

- 二叉树节点的深度：指从**根节点**到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）,一定是从根节点开始。
- 二叉树节点的高度：指从**该节点**到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）,从该节点开始。

##### 递归法

- 加1：因为当前时中间节点，如果是最后一个节点需要加上这个中间节点
- 递归结束条件：当前节点为空
- 使用后序遍历不需要回溯

```c++
//后序遍历
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;

        return 1 + max(maxDepth(root->left), maxDepth(root->right)); 
    }
};
```

##### 回溯法

- 回溯法使用前序遍历

```c++
class Solution {
public:
    int ret = 0;

    void getdepth(TreeNode* root, int depth)
    {
        ret = depth > ret ? depth : ret;    //中
        if(root->left == nullptr && root->right == nullptr) return;

        if(root->left)  //左
        {
            depth++;
            getdepth(root->left, depth);
            depth--; //回溯
        }

        if(root->right) //右
        {
            depth++;
            getdepth(root->right, depth);
            depth--;
        }

        return;
    }

    int maxDepth(TreeNode* root) {
        if(root == nullptr) return ret;

        getdepth(root, 1);

        return ret;
    }
};
```

##### 迭代法

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        int depth = 0;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
            depth++;
        }
        return depth;
    }
};
```

#### 二叉树的最小深度

- 迭代法容易理解

##### 迭代法

- BFS遍历遇到节点没有左右节点就返回即可

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        int depth = 0;
        while(!que.empty())
        {
            int size = que.size();
            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
                if(!node->left && !node->right) return ++depth;
            }

            depth++;
        }

        return depth;
    }
};
```

##### 递归法

```c++
//未精简
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);           // 左
        int rightDepth = getDepth(node->right);         // 右
                                                        // 中
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```

```c++
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root == nullptr) return 0;

        if(root->left == nullptr && root->right != nullptr)
        {
            return 1 + minDepth(root->right);
        }

        if(root->right == nullptr && root->left != nullptr)
        {
            return 1 + minDepth(root->left);
        }
		
        //如果左右子节点都不为空继续递归左右子树
        return 1 + min(minDepth(root->left), minDepth(root->right));
    }
};
```

#### 完全二叉树节点个数

##### 递归法

- 递归结束条件：root == nullptr
- 返回值：1(中间节点) + 左子树节点个数 + 右子树节点个数

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;

        return 1 + countNodes(root->left) + countNodes(root->right);
    }
};
```

##### 迭代法

- 累加每层节点数量

```c++
class Solution {
public:
    int countNodes(TreeNode* root) {
        queue<TreeNode*> que;
        if(root != nullptr) que.push(root);
        int ret = 0;
        while(!que.empty())
        {
            int size = que.size();
            ret += size;

            for(int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }

        return ret;
    }
};
```

#### 平衡二叉树

##### 高度与深度再巩固

<img src="./assets/高度与深度.png" alt="高度与深度" style="zoom: 50%;" />

##### 递归法

- 递归函数的参数和返回值：参数是当前传入节点、返回值是以当前传入节点为根节点的树的高度或者-1
- 递归函数的终止条件：当前传入节点为空
- 递归单层调用逻辑：分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。

```c++
class Solution {
public:
    int getHeigth(TreeNode* root)
    {
        if(root == nullptr) return 0;
        int leftH = getHeigth(root->left);
        int rightH = getHeigth(root->right);

        if(leftH == -1) return -1;
        if(rightH == -1) return -1;

        return abs(leftH - rightH) > 1 ? -1 : 1 + max(leftH, rightH);	//取最大值为高度
    }

    bool isBalanced(TreeNode* root) {
        if(getHeigth(root) == -1)
        return false;
        return true;
    }
};
```

#### 二叉树的所有路径

##### 回溯法

- 根节点到叶子节点：前序遍历
- 递归(回溯)函数的参数和返回值：void traversal(TreeNode* cur, vector<int>& path, vector<string>& ret)
- 终止条件：找到叶子节点：if(cur->right == nullptr && cur->left == nullptr)
- 单层调用逻辑：当前节点存在左或右子节点时以左或右节点为根节点递归，并且回溯一次。

```c++
class Solution {
public:
    void traversal(TreeNode* cur, vector<int>& path, vector<string>& ret)
    {
        path.push_back(cur->val);
        if(cur->right == nullptr && cur->left == nullptr)
        {
            string spath;
            for(int i = 0; i < path.size() - 1; i++)
            {
                spath += to_string(path[i]);
                spath += "->";
            }

            spath += to_string(path[path.size() - 1]);
            ret.push_back(spath);
            return;
        }

        if(cur->left)
        {
            traversal(cur->left, path, ret);
            path.pop_back();
        }

        if(cur->right)
        {
            traversal(cur->right, path, ret);
            path.pop_back();
        }
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<int> path;
        vector<string> ret;
        if(root == nullptr) return ret;
        traversal(root, path, ret);

        return ret;
    }
};
```

简化版本

```c++
class Solution {
public:
    void traversal(TreeNode* cur, string path, vector<string>& ret)
    {
        path += to_string(cur->val);
        if(cur->left == nullptr && cur->right == nullptr)
        {
            ret.push_back(path);
            return;
        }

        //path + "->" 作为参数传入，没有改变path的值，相当于执行函数后自动回溯了
        //path1(函数执行的path) = path + "->";
        if(cur->left) traversal(cur->left, path + "->", ret);   //左
        if(cur->right) traversal(cur->right, path + "->", ret); //右
    }

    vector<string> binaryTreePaths(TreeNode* root) {
        string path;
        vector<string> ret;
        if(root == nullptr) return ret;

        traversal(root, path, ret);

        return ret;
    }
};
```

#### 左叶子之和

- 不能通过当前节点判断该节点是否是左叶子节点，需要通过父节点判断是否存在左叶子。所有递归要使用后序遍历。
- 当遇到左叶子节点的时候，记录数值，然后通过递归求取左子树左叶子之和，和 右子树左叶子之和，相加便是整个树的左叶子之和。

##### 递归法

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == nullptr) return 0;
        else if(!root->left && !root->right) return 0;

        int leftValue = sumOfLeftLeaves(root->left);
        if(root->left && !root->left->left && !root->left->right)
        {
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);

        return rightValue + leftValue;
    }
};
```

##### 迭代法

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        int ret = 0;
        queue<TreeNode*> que;
        if(root == nullptr || (root->left == nullptr && root->right == nullptr)) return 0;
        que.push(root);

        while(!que.empty())
        {
            int size = que.size();

            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();

                if(node->left) 
                {
                    que.push(node->left);
                    if(node->left->left == nullptr && node->left->right == nullptr)
                    ret += node->left->val;
                }
                if(node->right) que.push(node->right);


            }
        }

        return ret;
    }
};

```

#### 找树左下角的值

##### 层序遍历法

- 返回最后一层第一个元素即可

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        int ret = 0;
        queue<TreeNode*> que;
        if(root) que.push(root);

        while(!que.empty())
        {
            int size = que.size();

            for(int i = 0; i < size; i++)
            {
                TreeNode *node = que.front();
                que.pop();

                if(i == 0) ret = node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }

        return ret;
    }
};
```

##### 递归法

- 记录当前节点深度，如果大于最大深度，更新ret的值
- 使用前序遍历(或中序遍历)确保左节点优先遍历

```c++
class Solution {
public:
    int maxDepth = INT_MIN;
    int ret;

    void traversal(TreeNode *root, int depath)
    {
        if(!root->left && !root->right)
        {
            if(depath > maxDepth)
            {
                maxDepth = depath;
                ret = root->val;
            }
            return;
        }

        if(root->left) traversal(root->left, depath + 1);
        if(root->right) traversal(root->right, depath + 1);

        return;

    }

    int findBottomLeftValue(TreeNode* root) {
        traversal(root, 0);

        return ret;
    }
};
```

#### 路径总和

##### 递归法

```c++
class Solution {
public:
    bool traversal(TreeNode* root, int targetSum)
    {
        if(!root->left && !root->right && targetSum == 0) return true;
        if(!root->left && !root->right) return false;

        if(root->left)
        {
            if(traversal(root->left, targetSum - root->left->val))
            return true;
        }
        if(root->right) 
        {
            if(traversal(root->right, targetSum - root->right->val))
            return true;
        }

        return false;
    }
        
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        return traversal(root, targetSum - root->val);
    }
};
```

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && targetSum == root->val) return true;

        return hasPathSum(root->left, targetSum - root->val) 
            || hasPathSum(root->right, targetSum - root->val);
    } 
};
```

##### 迭代法

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        stack<pair<TreeNode*, int>> st;
        if(root) st.push(pair<TreeNode*, int>(root, root->val));

        while(!st.empty())
        {
            pair<TreeNode*, int> node = st.top();
            st.pop();
            if(!node.first->left && !node.first->right && targetSum == node.second)
            return true;

            if(node.first->right)
            {
                st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
            }

            if (node.first->left) 
            {
                st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }

        return false;
    }
};
```

#### 从中序与后序遍历序列构造二叉树

